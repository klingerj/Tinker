#pragma once

#define DISABLE_MEM_TRACKING
#include "../Include/Core/CoreDefines.h"

#include <stdio.h>

namespace SPIRV_VM
{

struct Insn
{
    uint32 opcode;
};

struct VM_Shader
{
    uint32 numInsns;
    uint32 boundNum; // insn id max value
    Insn* insns;
};

struct SPIRV_VM_State
{
    // TODO: actual registers or something
    uint64 regA;
    uint64 regB;
};

class SPIRV_VM
{
private:
    SPIRV_VM_State m_state;

public:
    SPIRV_VM() {}
    ~SPIRV_VM() {}

    void Init()
    {
        // TODO: some init
        m_state = {};
    }

    const SPIRV_VM_State& QueryState()
    {
        return m_state;
    }

    VM_Shader CreateShader(const uint32* spvFile, uint32 fileSizeInBytes)
    {
        const uint32* spvFileBase = spvFile;
        const uint32* spvFilePtr = spvFileBase;

        // Header
        {
            uint32 magicNumber = *spvFilePtr;
            printf("Magic number: %x\n", magicNumber);
            ++spvFilePtr;

            uint32 versionBytes = *spvFilePtr;
            uint8 major = (uint8)((versionBytes & 0x00FF0000) >> 16);
            uint8 minor = (uint8)((versionBytes & 0x0000FF00) >> 8);
            printf("Major version number: %d\n", major);
            printf("Minor version number: %d\n", minor);
            ++spvFilePtr;

            uint32 generatorMagicNumber = *spvFilePtr;
            generatorMagicNumber >>= 16; // want upper 16 bits for generator number
            printf("Generator magic number: %d\n", generatorMagicNumber);
            ++spvFilePtr;

            if (generatorMagicNumber == 8)
            {
                printf("SPV generated by Khronos's Glslang Reference Front End.\n");
            }
            else
            {
                // TODO: print message for other spv generators?
            }
            
        }

        uint32 bound = *spvFilePtr; // max id number
        printf("Bound number: %d\n", bound);
        ++spvFilePtr;

        // TODO: figure out how many instructions are in the file
        // Allocate shader instructions
        const uint32 maxNumInsns = 4096;
        Insn* insns = new Insn[4096];
        uint32 numInsns = 0;

        uint32 wordsRead = (uint32)(spvFilePtr - spvFileBase);
        while ((wordsRead * 4) < fileSizeInBytes)
        {
            uint32 opcode = *spvFilePtr;
            insns[numInsns].opcode = opcode;
            ++numInsns;
            printf("Opcode: %x\n", opcode);
            ++spvFilePtr;
            
            // TODO: process instructions
            // e.g. extract insn enumerant




            wordsRead = (uint32)(spvFilePtr - spvFileBase);
        }

        VM_Shader newShader = {};
        newShader.numInsns = numInsns;
        newShader.boundNum = bound;
        newShader.insns = insns;
        return newShader;
    }

    void DestroyShader(const VM_Shader& shader)
    {
        delete shader.insns;
    }

    void ExecuteShader(const VM_Shader& shader)
    {
        // TODO: execute shader instructions
        m_state.regA = 1;
        m_state.regB = 2;
    }
};

}
