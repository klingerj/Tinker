#pragma once

#define DISABLE_MEM_TRACKING
#include "../Include/Core/CoreDefines.h"

#include <stdio.h>
#include <cstring>

namespace SPIRV_VM
{

#define MAX_SHADER_INSNS 4096

struct Insn
{
    uint32 opcode;
};

struct VM_Shader
{
    uint32 numInsns;
    uint32 boundNum; // insn id max value
    Insn* insns;
};

VM_Shader CreateShader(const uint32* spvFile, uint32 fileSizeInBytes)
{
    const uint32* spvFileBase = spvFile;
    const uint32* spvFilePtr = spvFileBase;

    // Header
    {
        uint32 magicNumber = *spvFilePtr;
        printf("Magic number: %x\n", magicNumber);
        ++spvFilePtr;

        uint32 versionBytes = *spvFilePtr;
        uint8 major = (uint8)((versionBytes & 0x00FF0000) >> 16);
        uint8 minor = (uint8)((versionBytes & 0x0000FF00) >> 8);
        printf("Major version number: %d\n", major);
        printf("Minor version number: %d\n", minor);
        ++spvFilePtr;

        uint32 generatorMagicNumber = *spvFilePtr;
        generatorMagicNumber >>= 16; // want upper 16 bits for generator number
        printf("Generator magic number: %d\n", generatorMagicNumber);
        ++spvFilePtr;

        if (generatorMagicNumber == 8)
        {
            printf("SPV generated by Khronos's Glslang Reference Front End.\n");
        }
        else
        {
            // TODO: print message for other spv generators?
        }

    }

    uint32 bound = *spvFilePtr; // max id number
    printf("Bound number: %d\n", bound);
    ++spvFilePtr;

    // TODO: figure out how many instructions are in the file
    // Allocate shader instructions
    Insn* insns = new Insn[MAX_SHADER_INSNS];
    uint32 numInsns = 0;

    uint32 wordsRead = (uint32)(spvFilePtr - spvFileBase);
    while ((wordsRead * 4) < fileSizeInBytes)
    {
        uint32 opcode = *spvFilePtr;
        insns[numInsns].opcode = opcode;
        ++numInsns;
        printf("Opcode: %x\n", opcode);
        ++spvFilePtr;

        // TODO: process instructions
        // e.g. extract insn enumerant



        wordsRead = (uint32)(spvFilePtr - spvFileBase);
    }

    VM_Shader newShader = {};
    newShader.numInsns = numInsns;
    newShader.boundNum = bound;
    newShader.insns = insns;
    return newShader;
}

void DestroyShader(const VM_Shader& shader)
{
    delete shader.insns;
}

struct Descriptors
{
    // TODO: uniform data
    struct
    {
        float someData[4];
    } descriptorSets[3];

    void Init()
    {
        descriptorSets[0] = {};
        descriptorSets[1] = {};
        descriptorSets[2] = {};
    }

    bool operator==(const Descriptors& other) const
    {
        bool result = true;

        for (uint32 i = 0; i < 3; ++i)
        {
            result &= descriptorSets[i].someData[0] == other.descriptorSets[i].someData[0];
            result &= descriptorSets[i].someData[1] == other.descriptorSets[i].someData[1];
            result &= descriptorSets[i].someData[2] == other.descriptorSets[i].someData[2];
            result &= descriptorSets[i].someData[3] == other.descriptorSets[i].someData[3];
        }

        return result;
    }
    bool operator!=(const Descriptors& other) const
    {
        return !(*this == other);
    }
};

struct State
{
    uint32 programCounter;
    // TODO: actual registers or something
    uint64 regA;
    uint64 regB;

    void Init()
    {
        programCounter = 0;
        regA = 0;
        regB = 0;
    }

    bool operator==(const State& other) const
    {
        return (programCounter == other.programCounter &&
            regA == other.regA &&
            regB == other.regB);
    }
    bool operator!=(const State& other) const
    {
        return !(*this == other);
    }
};

template <typename T>
struct State_Log
{
    uint32 nextStateIndex;
    T previousStates[MAX_SHADER_INSNS + 1];

    void Init()
    {
        nextStateIndex = 0;
        for (uint16 i = 0; i < MAX_SHADER_INSNS + 1; ++i)
        {
            previousStates[i].Init();
        }
    }
};
typedef SPIRV_VM::State_Log<SPIRV_VM::State> StateLog;
typedef SPIRV_VM::State_Log<SPIRV_VM::Descriptors> DescLog;

template <typename T>
void SaveStateInLog(State_Log<T>* log, T* state)
{
    log->previousStates[log->nextStateIndex++] = *state;
}

template <typename T>
void RestoreLastStateFromLog(State_Log<T>* log, T* state)
{
    memcpy(state, &log->previousStates[--log->nextStateIndex], sizeof(T));
}

void ExecuteSingleInsn(State* state, Descriptors* descriptors, const Insn& insn)
{
    // TODO: execute shader instructions
    state->regA++;
    state->regB++;
    descriptors->descriptorSets[0].someData[0] += 2.1f;
}

void StepForwardShader(State* state, Descriptors* descriptors, VM_Shader* shader)
{
    const Insn& insn = shader->insns[state->programCounter];
    ExecuteSingleInsn(state, descriptors, insn);
    ++state->programCounter;
}

void ExecuteEntireShader(State* state, Descriptors* descriptors, VM_Shader* shader)
{
    for (uint32 uiInsn = 0; uiInsn < shader->numInsns; ++uiInsn)
    {
        ExecuteSingleInsn(state, descriptors, shader->insns[state->programCounter]);
    }
}

}
